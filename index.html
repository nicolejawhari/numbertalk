<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whole Number Shading Tool</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ====================================
           CSS STYLES 
           (Use this section for your CSS slot)
           ==================================== */
        
        /* Basic reset and font for readability */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* bg-gray-50 */
        }
        
        /* Ensures the grid cells maintain aspect ratio */
        .grid-cell {
            aspect-ratio: 1 / 1;
            transition: background-color 0.2s;
            /* Default unshaded color */
            background-color: #e5e7eb; /* bg-gray-200/80 */
        }
        
        /* Input focus color to match theme */
        .input-focus:focus {
            border-color: #14b8a6; /* border-teal-500 */
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.4); /* ring-teal-500 */
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8 flex flex-col items-center justify-start">
    
    <!-- NEW: EXIT DISPLAY MODE BUTTON -->
    <div id="exit-display-btn" class="fixed top-4 left-4 z-50 hidden">
        <button onclick="exitDisplayMode()" class="bg-gray-700 text-white text-xs px-3 py-1 rounded-md shadow-lg opacity-70 hover:opacity-100 transition-opacity">
            Exit Display Mode
        </button>
    </div>

    <!-- ====================================
         HTML STRUCTURE 
         (Use this section for your HTML slot)
         ==================================== -->

    <div id="app-container" class="w-full max-w-4xl bg-white p-6 sm:p-8 rounded-xl shadow-2xl transition-all duration-300 mb-8">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl font-extrabold text-gray-900">
                Whole Number Shading Tool
            </h1>
            <p class="text-sm text-gray-500 mt-1">
                Both inputs handle numbers up to 100,000, grouped by hundreds, thousands, 10 thousands.
            </p>
        </header>

        <!-- DUAL INPUT CONTROLS -->
        <div id="input-controls" class="flex flex-col md:flex-row justify-center gap-6">
            
            <!-- Input 1 (Up to 100,000) -->
            <div class="flex-1 bg-gray-50 p-4 rounded-lg border border-gray-200">
                <label for="shadeInput1" class="block text-lg font-bold text-teal-700 mb-2">
                    Input A <span id="shadeCountDisplay1" class="font-extrabold">(42)</span>
                </label>
                
                <input
                    id="shadeInput1"
                    type="number"
                    min="0"
                    max="100000"
                    value="0"
                    class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-sm text-xl text-center font-mono transition-all duration-150 input-focus"
                    placeholder="Enter A (0-100000)"
                />
                <p class="text-xs text-gray-400 mt-2 text-right">
                    Current A: <span id="currentInputCount1">42</span> / 100000
                </p>
            </div>

            <!-- Input 2 (Up to 100,000) -->
            <div class="flex-1 bg-gray-50 p-4 rounded-lg border border-gray-200">
                <label for="shadeInput2" class="block text-lg font-bold text-teal-700 mb-2">
                    Input B <span id="shadeCountDisplay2" class="font-extrabold">(56)</span>
                </label>
                
                <input
                    id="shadeInput2"
                    type="number"
                    min="0"
                    max="100000"
                    value="0"
                    class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-sm text-xl text-center font-mono transition-all duration-150 input-focus"
                    placeholder="Enter B (0-100000)"
                />
                <p class="text-xs text-gray-400 mt-2 text-right">
                    Current B: <span id="currentInputCount2">56</span> / 100000
                </p>

                <!-- COLOR TOGGLE -->
                <div class="flex items-center mt-3">
                    <input id="colorToggleB" type="checkbox" class="h-4 w-4 text-orange-600 rounded focus:ring-orange-500 border-gray-300" onchange="updateGrids()">
                    <label for="colorToggleB" class="ml-2 block text-sm font-medium text-gray-700">
                        Shade with Orange
                    </label>
                </div>
                
                <!-- NEW LINE TOGGLE -->
                <div class="flex items-center mt-2">
                    <input id="lineToggleB" type="checkbox" class="h-4 w-4 text-teal-600 rounded focus:ring-teal-500 border-gray-300" onchange="updateGrids()">
                    <label for="lineToggleB" class="ml-2 block text-sm font-medium text-gray-700">
                        Start Input B on new line
                    </label>
                </div>

                <!-- HIDE INPUTS TOGGLE -->
                <div class="flex items-center mt-4 pt-3 border-t border-gray-200">
                    <input id="hideInputsToggle" type="checkbox" class="h-4 w-4 text-gray-600 rounded focus:ring-gray-500 border-gray-300" onchange="updateGrids()">
                    <label for="hideInputsToggle" class="ml-2 block text-sm font-bold text-gray-700">
                        Classroom Mode
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Grid Container: This will hold all the dynamically generated grids -->
    <div id="grid-container" class="w-full max-w-6xl p-4">
        <!-- Grids will be generated here by JavaScript -->
    </div>

    <!-- ====================================
         JAVASCRIPT LOGIC 
         (Use this section for your JS slot)
         ==================================== -->
    <script>
        const GRID_ROWS = 10;
        const GRID_COLS = 10;
        const MAX_GRID_SIZE = GRID_ROWS * GRID_COLS;
        const MAX_INPUT_A = 100000;
        const MAX_INPUT_B = 100000; 

        // Color Constants
        const COLOR_TEAL_HEX = '#0d9488';   // Teal 600 (for Input A default and B when unchecked)
        const COLOR_ORANGE_HEX = '#fb923c'; // Orange 400 (Slightly Softer Orange for Input B when checked)

        const gridContainer = document.getElementById('grid-container');
        const appContainer = document.getElementById('app-container');
        const headerElement = document.querySelector('header');
        const inputControls = document.getElementById('input-controls');
        const exitDisplayButton = document.getElementById('exit-display-btn');

        // Input 1 Elements
        const shadeInput1 = document.getElementById('shadeInput1');
        const shadeCountDisplay1 = document.getElementById('shadeCountDisplay1');
        const currentInputCount1 = document.getElementById('currentInputCount1');

        // Input 2 Elements
        const shadeInput2 = document.getElementById('shadeInput2');
        const shadeCountDisplay2 = document.getElementById('shadeCountDisplay2');
        const currentInputCount2 = document.getElementById('currentInputCount2');

        // Toggle Elements
        const colorToggleB = document.getElementById('colorToggleB');
        const lineToggleB = document.getElementById('lineToggleB'); 
        const hideInputsToggle = document.getElementById('hideInputsToggle'); 

        let currentCount1 = parseInt(shadeInput1.value, 10);
        let currentCount2 = parseInt(shadeInput2.value, 10);
        
        // Classes for the special 1000 block (reduced prominence)
        const THOUSAND_WRAPPER_CLASSES = [
            'flex-none', 'shadow-md', 'rounded-xl', 'bg-gray-100', 
            'border-2', 'border-gray-500', 
            'w-full', 'sm:w-[48%]', 'md:w-[18%]' // Allows 5 blocks per row on desktop
        ];
        
        /**
         * Clamps the input value between 0 and a custom max.
         */
        function clampValue(value, max) {
            let num = parseInt(value, 10);
            if (isNaN(num) || num < 0) {
                num = 0;
            } else if (num > max) {
                num = max;
            }
            return num;
        }

        /**
         * Calculates the required shading counts for a given total (up to 1000).
         */
        function calculateGridData(totalCount) {
            if (totalCount === 0) {
                return [];
            }
            
            const fullGrids = Math.floor(totalCount / 100);
            const remainder = totalCount % 100;
            
            const gridsToRender = [];
            
            for (let i = 0; i < fullGrids; i++) {
                gridsToRender.push({ count: 100 });
            }

            if (remainder > 0) {
                gridsToRender.push({ count: remainder });
            }
            
            return gridsToRender;
        }

        /**
         * Generates and shades a single 10x10 grid (Hundred unit).
         */
        function createAndS_hadeGrid(shadeCount, isCompact = false, shadedColor = COLOR_TEAL_HEX) {
            const gridWrapper = document.createElement('div');
            
            if (isCompact) {
                gridWrapper.classList.add('p-px'); 
            } else {
                gridWrapper.classList.add('grid-panel', 'p-3', 'bg-white', 'rounded-xl', 'shadow-lg', 'w-full', 'sm:w-[31%]', 'md:w-[18%]', 'border-2', 'border-black'); 
            }

            const innerGrid = document.createElement('div');
            const gapClass = isCompact ? 'gap-px' : 'gap-0.5';
            innerGrid.classList.add('grid', gapClass, 'w-full', 'aspect-square', 'p-px', 'bg-gray-100', 'rounded-sm'); 
            innerGrid.style.gridTemplateColumns = `repeat(${GRID_COLS}, minmax(0, 1fr)`;

            for (let standardIndex = 0; standardIndex < MAX_GRID_SIZE; standardIndex++) {
                const cell = document.createElement('div');
                const cellBorderClass = isCompact ? 'border-none' : 'border-gray-300/50';

                cell.classList.add('grid-cell', 'rounded-sm', 'border', cellBorderClass);
                
                // Rotational Shading Logic (remains unchanged)
                const r = Math.floor(standardIndex / GRID_COLS);
                const c = standardIndex % GRID_COLS;
                const cellsInPrecedingColumns = c * GRID_ROWS; 
                const positionInColumn = (GRID_ROWS - 1) - r; 
                const rotatedShadingIndex = cellsInPrecedingColumns + positionInColumn;
                
                const isShaded = rotatedShadingIndex < shadeCount;

                if (isShaded) {
                    cell.style.backgroundColor = shadedColor;
                }
                
                innerGrid.appendChild(cell);
            }
            
            gridWrapper.appendChild(innerGrid);
            return gridWrapper;
        }

        /**
         * Generates a single thousands block (10 grids) with compact sizing (5x2 layout).
         */
        const renderSingleThousandsBlock = (shadedColor = COLOR_TEAL_HEX) => {
            const blockWrapper = document.createElement('div');
            blockWrapper.classList.add(...THOUSAND_WRAPPER_CLASSES);
            
            const innerGridContainer = document.createElement('div');
            innerGridContainer.classList.add('grid', 'gap-1', 'p-1'); 
            innerGridContainer.style.gridTemplateColumns = `repeat(5, 1fr)`;
            
            blockWrapper.appendChild(innerGridContainer);
            
            // Render 10 full grids (1000), always compacted
            for (let i = 0; i < 10; i++) {
                innerGridContainer.appendChild(createAndS_hadeGrid(100, true, shadedColor));
            }
            return blockWrapper;
        };
        
        /**
         * Renders the grid visualization for a single input, handling all units,
         * and applies a border around every 10 full thousand blocks (10,000 unit).
         */
        function renderInputGrids(count, color, container) {
            if (count === 0) return;

            const K_BLOCKS_PER_10K = 10;
            
            // Determine the total number of 1000 blocks and the final remainder (0-999)
            const fullThousands = Math.floor(count / 1000);
            const remainder = count % 1000;

            let blocksToRender = [];
            // Add all full 1000 blocks to an array
            for (let i = 0; i < fullThousands; i++) {
                blocksToRender.push(renderSingleThousandsBlock(color));
            }
            
            // ----------------------------------------------------
            // CORE LOGIC: GROUPING BLOCKS INTO 10K UNITS
            // ----------------------------------------------------
            
            let currentBlockIndex = 0;
            while (currentBlockIndex < blocksToRender.length) {
                
                // Check if we can form a full 10,000 unit
                if (currentBlockIndex % K_BLOCKS_PER_10K === 0 && (blocksToRender.length - currentBlockIndex) >= K_BLOCKS_PER_10K) {
                    
                    const tenKWrapper = document.createElement('div');
                    // Styles for the 10K border block. Use full width for clear visual grouping.
                    tenKWrapper.classList.add('w-full', 'border-4', 'border-black', 'rounded-xl', 'p-3', 'bg-gray-100', 'shadow-xl', 'my-2', 'mx-auto', 'max-w-5xl'); 

                    const internalFlow = document.createElement('div');
                    // Ensure internal flow allows 5 blocks per row and manages gap.
                    internalFlow.classList.add('flex', 'flex-wrap', 'justify-start', 'gap-3');
                    
                    // Add 10 1K blocks inside the new wrapper
                    for (let k = 0; k < K_BLOCKS_PER_10K; k++) {
                        internalFlow.appendChild(blocksToRender[currentBlockIndex + k]);
                    }
                    
                    tenKWrapper.appendChild(internalFlow);
                    container.appendChild(tenKWrapper);
                    currentBlockIndex += K_BLOCKS_PER_10K; // Skip 10 blocks
                } else {
                    // Render single 1K block (part of a remainder 10K group, or the last partial 10K group)
                    container.appendChild(blocksToRender[currentBlockIndex]);
                    currentBlockIndex++;
                }
            }
            
            // 2. Render Remainder Grids (100s/10s/1s)
            if (remainder > 0) {
                const dataRemainder = calculateGridData(remainder);
                dataRemainder.forEach(gridData => {
                    container.appendChild(createAndS_hadeGrid(gridData.count, false, color));
                });
            }
        }

        // --- LOCAL STORAGE FUNCTIONS (Persistence logic) ---

        /**
         * Saves the current input values and toggle states to the browser's localStorage.
         */
        function saveInputValues() {
            localStorage.setItem('shaderCountA', currentCount1);
            localStorage.setItem('shaderCountB', currentCount2);
            localStorage.setItem('shaderColorB', colorToggleB.checked);
            localStorage.setItem('shaderLineB', lineToggleB.checked);
            localStorage.setItem('shaderHideInputs', hideInputsToggle.checked);
        }
        
        /**
         * Loads saved input values from localStorage and updates the DOM elements.
         */
        function loadInputValues() {
            const savedA = localStorage.getItem('shaderCountA');
            const savedB = localStorage.getItem('shaderCountB');
            const savedColorB = localStorage.getItem('shaderColorB');
            const savedLineB = localStorage.getItem('shaderLineB');
            const savedHideInputs = localStorage.getItem('shaderHideInputs');


            if (savedA !== null) {
                currentCount1 = parseInt(savedA, 10);
                shadeInput1.value = currentCount1;
            }
            if (savedB !== null) {
                currentCount2 = parseInt(savedB, 10);
                shadeInput2.value = currentCount2;
            }
            
            if (savedColorB !== null) {
                colorToggleB.checked = (savedColorB === 'true');
            }
            if (savedLineB !== null) {
                lineToggleB.checked = (savedLineB === 'true');
            }
            if (savedHideInputs !== null) {
                 hideInputsToggle.checked = (savedHideInputs === 'true');
            }
            
            shadeCountDisplay1.textContent = `(${currentCount1})`;
            currentInputCount1.textContent = currentCount1;
            shadeCountDisplay2.textContent = `(${currentCount2})`;
            currentInputCount2.textContent = currentCount2;
        }

        /**
         * Exits display mode by clearing localStorage flag or URL parameter.
         */
        window.exitDisplayMode = function() {
            // Explicitly ensure the current input values are captured and saved before reload.
            currentCount1 = clampValue(shadeInput1.value, MAX_INPUT_A);
            currentCount2 = clampValue(shadeInput2.value, MAX_INPUT_B);
            
            saveInputValues(); 

            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.get('display') === 'true') {
                const newUrl = window.location.origin + window.location.pathname;
                window.location.href = newUrl;
            } else {
                localStorage.setItem('shaderHideInputs', 'false');
                window.location.reload();
            }
        };

        /**
         * Checks for the URL query parameter OR the toggle state to enable display mode.
         */
        function applyDisplayMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const isUrlLocked = urlParams.get('display') === 'true';
            
            const isDisplayMode = isUrlLocked || hideInputsToggle.checked;
            
            if (isDisplayMode) {
                
                headerElement.classList.add('hidden'); 
                inputControls.classList.add('hidden');
                
                appContainer.classList.remove('bg-white', 'shadow-2xl', 'p-6', 'sm:p-8', 'mb-8', 'max-w-4xl'); 
                appContainer.classList.add('bg-transparent', 'shadow-none', 'p-0', 'mb-0', 'max-w-7xl'); 
                
                gridContainer.classList.remove('max-w-6xl');

                exitDisplayButton.classList.remove('hidden');

                if (isUrlLocked) {
                     hideInputsToggle.disabled = true;
                }
            } else {
                headerElement.classList.remove('hidden'); 
                inputControls.classList.remove('hidden');
                
                appContainer.classList.add('bg-white', 'shadow-2xl', 'p-6', 'sm:p-8', 'mb-8', 'max-w-4xl'); 
                appContainer.classList.remove('bg-transparent', 'shadow-none', 'p-0', 'mb-0', 'max-w-7xl'); 
                gridContainer.classList.add('max-w-6xl');
                hideInputsToggle.disabled = false;
                
                exitDisplayButton.classList.add('hidden');
            }
        }


        /**
         * Clears all existing grids and generates the required visualization based on input values.
         */
        window.updateGrids = function() {
            const countA = currentCount1;
            const countB = currentCount2;
            
            saveInputValues();
            applyDisplayMode(); 
            gridContainer.innerHTML = ''; 

            const colorB = colorToggleB.checked ? COLOR_ORANGE_HEX : COLOR_TEAL_HEX;
            const startBOnNewLine = lineToggleB.checked; 
            
            
            const mainWrapper = document.createElement('div');
            mainWrapper.classList.add('flex', 'flex-wrap', 'justify-start', 'gap-3', 'w-full');
            gridContainer.appendChild(mainWrapper);

            // Render Input A
            renderInputGrids(countA, COLOR_TEAL_HEX, mainWrapper);

            // Apply Conditional Line Break
            const isATreatedAsBlock = countA >= 1000;
            const isBTreatedAsBlock = countB >= 1000; 
            const shouldForceBreak = startBOnNewLine || isATreatedAsBlock || isBTreatedAsBlock;
            
            if (shouldForceBreak) {
                const breaker = document.createElement('div');
                breaker.classList.add('w-full', 'h-0', 'mt-6'); 
                mainWrapper.appendChild(breaker);
            }

            // Render Input B
            renderInputGrids(countB, colorB, mainWrapper);
        }
        
        /**
         * Event handler for the input fields.
         */
        function handleInput(event, inputNumber) {
            const max = inputNumber === 1 ? MAX_INPUT_A : MAX_INPUT_B;
            const clampedValue = clampValue(event.target.value, max);
            
            event.target.value = clampedValue;

            if (inputNumber === 1) {
                currentCount1 = clampedValue;
                shadeCountDisplay1.textContent = `(${clampedValue})`;
                currentInputCount1.textContent = clampedValue;
            } else {
                currentCount2 = clampedValue;
                shadeCountDisplay2.textContent = `(${clampedValue})`;
                currentInputCount2.textContent = clampedValue;
            }

            updateGrids();
        }

        // --- Initialization Sequence ---
        
        loadInputValues();

        shadeInput1.addEventListener('input', (e) => handleInput(e, 1));
        shadeInput2.addEventListener('input', (e) => handleInput(e, 2));

        // Apply display mode changes and render on load
        updateGrids(); 
    </script>
</body>
</html>
